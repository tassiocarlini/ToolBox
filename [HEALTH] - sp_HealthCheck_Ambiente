USE [master]
GO

/****** Object:  StoredProcedure [dbo].[sp_HealthCheck_Ambiente]    Script Date: 30/10/2025 14:43:30 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

/**********************************************************************************************************************
* NOME: usp_HealthCheck_Ambiente
*
* AUTOR: [Tassio/R2D2]
*
* DATA DE CRIAÇÃO: 06/10/2025
* DATA DE ALTERAÇÃO: 29/10/2025 - Adicionado filtro para '%prtsql%' na Seção 9.
*
* DESCRIÇÃO DETALHADA:
* A procedure executa as seguintes validações:
* 1. Latência Real do CDC (em segundos)
* 2. Status de Jobs de Manutenção
* 3. Utilização de Arquivo de Log
* 4. Configurações de Paralelismo (MAXDOP)
* 5. Configurações de Banco de Dados (Compatibilidade, Stats, Cardinalidade, Parametrização)
* 6. Status Crítico do Log por Replicação/CDC
* 7. Page Life Expectancy (PLE)
* 8. Cadeias de Bloqueio Ativas (Todos os BDs)
* 9. SPIDs Antigos (com filtro de exclusão)
* 10. Latência de Disco
*
* COMO USAR:
* EXEC dbo.usp_HealthCheck_Ambiente;
*
**********************************************************************************************************************/
CREATE   PROCEDURE [dbo].[sp_HealthCheck_Ambiente]
AS
BEGIN
    SET NOCOUNT ON;

    PRINT '=====================================================================';
    PRINT '==         INÍCIO DO HEALTH CHECK DO AMBIENTE SQL SERVER           ==';
    PRINT '==                Data: ' + CONVERT(VARCHAR, GETDATE(), 120) + '                  ==';
    PRINT '=====================================================================';
    PRINT CHAR(10);

    -- =====================================================================
    -- 1. LATÊNCIA REAL DO CDC (EM SEGUNDOS)
    -- =====================================================================
    PRINT '--- 1. Latência Real do CDC (em segundos) ---';
    PRINT 'INFO: Mede o tempo de atraso para bancos com database_id > 5.';

    IF OBJECT_ID('tempdb..#CDCLatencyReal') IS NOT NULL DROP TABLE #CDCLatencyReal;
    CREATE TABLE #CDCLatencyReal (DatabaseName NVARCHAR(128), LastProcessedTransactionTime DATETIME, LatencySeconds INT);

    IF EXISTS (SELECT 1 FROM sys.databases WHERE is_cdc_enabled = 1 AND database_id > 5)
    BEGIN
        DECLARE @db_name_cdc NVARCHAR(128), @sql_cdc NVARCHAR(MAX), @params NVARCHAR(MAX);
        SET @params = N'@db_name_param NVARCHAR(128)';
        DECLARE cdc_cursor CURSOR FOR SELECT name FROM sys.databases WHERE is_cdc_enabled = 1 AND state_desc = 'ONLINE' AND database_id > 5;
        OPEN cdc_cursor; FETCH NEXT FROM cdc_cursor INTO @db_name_cdc;
        WHILE @@FETCH_STATUS = 0
        BEGIN
            SET @sql_cdc = N'USE ' + QUOTENAME(@db_name_cdc) + N';
                           DECLARE @processed_time DATETIME;
                           SELECT @processed_time = MAX(tran_end_time) FROM cdc.lsn_time_mapping;
                           IF @processed_time IS NOT NULL
                           BEGIN
                               INSERT INTO #CDCLatencyReal (DatabaseName, LastProcessedTransactionTime, LatencySeconds)
                               VALUES ( @db_name_param, @processed_time, DATEDIFF(second, @processed_time, GETDATE()));
                           END';
            EXEC sp_executesql @sql_cdc, @params, @db_name_param = @db_name_cdc;
            FETCH NEXT FROM cdc_cursor INTO @db_name_cdc;
        END;
        CLOSE cdc_cursor; DEALLOCATE cdc_cursor;
    END;

    SELECT '1_Latencia_Real_CDC' AS Ponto_de_Verificacao, * FROM #CDCLatencyReal;
    IF @@ROWCOUNT = 0
    BEGIN
        SELECT '1_Latencia_Real_CDC' AS Ponto_de_Verificacao, 'Nenhum BD com CDC habilitado (ID > 5)' AS DatabaseName, NULL AS LastProcessedTransactionTime, NULL AS LatencySeconds;
    END
    DROP TABLE #CDCLatencyReal;
    PRINT CHAR(10);

    -- =====================================================================
    -- 2. STATUS DOS JOBS DE MANUTENÇÃO (NÍVEL DE INSTÂNCIA)
    -- =====================================================================
    PRINT '--- 2. Status da última execução dos Jobs de Manutenção ---';

    WITH JobHistory AS (
        SELECT
            j.name AS JobName,
            msdb.dbo.agent_datetime(h.run_date, h.run_time) AS LastRunDateTime,
            h.run_status,
            ROW_NUMBER() OVER(PARTITION BY j.name ORDER BY msdb.dbo.agent_datetime(h.run_date, h.run_time) DESC) AS RowNum
        FROM
            msdb.dbo.sysjobs AS j
        INNER JOIN
            msdb.dbo.sysjobhistory AS h ON j.job_id = h.job_id
        WHERE
            j.name IN ('Totvs | DBA Cloud - Maintenance', 'Totvs | DBA Cloud - Maintenance - Rebuild')
            AND h.step_id = 0
    )
    SELECT
        '2_Status_Jobs_Manutencao' AS Ponto_de_Verificacao,
        JobName,
        LastRunDateTime,
        CASE run_status
            WHEN 0 THEN 'Falhou'
            WHEN 1 THEN 'Sucesso'
            WHEN 2 THEN 'Tentando Novamente'
            WHEN 3 THEN 'Cancelado'
            ELSE 'Status Desconhecido'
        END AS RunStatus
    FROM
        JobHistory
    WHERE
        RowNum = 1;

    IF @@ROWCOUNT = 0
    BEGIN
        SELECT '2_Status_Jobs_Manutencao' AS Ponto_de_Verificacao, 'Nenhum dos jobs foi encontrado ou executado' AS JobName, NULL AS LastRunDateTime, 'N/A' AS RunStatus;
    END
    PRINT CHAR(10);

    -- =====================================================================
    -- 3. UTILIZAÇÃO DO ARQUIVO DE LOG (Databases > 5)
    -- =====================================================================
    PRINT '--- 3. Utilização do Arquivo de Log (%) ---';
    IF OBJECT_ID('tempdb..#LogUsage') IS NOT NULL DROP TABLE #LogUsage;
    CREATE TABLE #LogUsage ([Database] NVARCHAR(128), [Tamanho Total Log (MB)] DECIMAL(18,2), [Espaço Usado Log (MB)] DECIMAL(18,2), [Percentual Usado (%)] DECIMAL(5,2), [Motivo de Espera de Reutilização] NVARCHAR(60));
    DECLARE @db_name_log NVARCHAR(128), @sql_log NVARCHAR(MAX);
    DECLARE log_cursor CURSOR FOR SELECT name FROM sys.databases WHERE database_id > 5 AND state_desc = 'ONLINE';
    OPEN log_cursor; FETCH NEXT FROM log_cursor INTO @db_name_log;
    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @sql_log = N'USE ' + QUOTENAME(@db_name_log) + N'; INSERT INTO #LogUsage SELECT DB_NAME(), ls.total_log_size_in_bytes / 1024.0 / 1024.0, ls.used_log_space_in_bytes / 1024.0 / 1024.0, ls.used_log_space_in_percent, db.log_reuse_wait_desc FROM sys.dm_db_log_space_usage AS ls CROSS JOIN sys.databases AS db WHERE db.database_id = DB_ID();';
        EXEC sp_executesql @sql_log; FETCH NEXT FROM log_cursor INTO @db_name_log;
    END
    CLOSE log_cursor; DEALLOCATE log_cursor;

    SELECT '3_Utilizacao_Arquivo_Log' AS Ponto_de_Verificacao, * FROM #LogUsage ORDER BY [Percentual Usado (%)] DESC;
    IF @@ROWCOUNT = 0
    BEGIN
         SELECT '3_Utilizacao_Arquivo_Log' AS Ponto_de_Verificacao, 'Nenhum BD encontrado (ID > 5)' AS [Database], NULL AS [Tamanho Total Log (MB)], NULL AS [Espaço Usado Log (MB)], NULL AS [Percentual Usado (%)], NULL AS [Motivo de Espera de Reutilização];
    END
    DROP TABLE #LogUsage;
    PRINT CHAR(10);

    -- =====================================================================
    -- 4. CONFIGURAÇÕES DE PARALELISMO (NÍVEL DE INSTÂNCIA)
    -- =====================================================================
    PRINT '--- 4. Configurações de Paralelismo (MAXDOP e Cost Threshold) ---';
    PRINT 'INFO: Verifica as configurações de paralelismo da instância.';
    PRINT '      Boas práticas sugerem Cost Threshold > 30 e MAXDOP <= 8 (ou <= nº de cores em um nó NUMA).';
    SELECT
        '4_Config_Paralelismo' AS Ponto_de_Verificacao,
        (SELECT value_in_use FROM sys.configurations WHERE name = 'max degree of parallelism') AS [MAXDOP_Configurado],
        (SELECT value_in_use FROM sys.configurations WHERE name = 'cost threshold for parallelism') AS [Cost_Threshold_Configurado];
    PRINT CHAR(10);

    -- =====================================================================
    -- 5. CONFIGURAÇÕES DE BANCO DE DADOS (Databases > 5)
    -- =====================================================================
    PRINT '--- 5. Configurações de Banco de Dados (para database_id > 5) ---';
    PRINT 'INFO: Verifica configurações a nível de banco que afetam o otimizador de consultas.';

    IF OBJECT_ID('tempdb..#DbConfigs') IS NOT NULL DROP TABLE #DbConfigs;
    CREATE TABLE #DbConfigs (
        [Database] NVARCHAR(128),
        [Nivel_Compatibilidade] TINYINT,
        [Auto_Create_Stats] BIT,
        [Legacy_Cardinality_On] BIT,
        [Parameterization] NVARCHAR(60)
    );
    DECLARE @db_name_conf NVARCHAR(128), @sql_conf NVARCHAR(MAX);
    DECLARE conf_cursor CURSOR FOR SELECT name FROM sys.databases WHERE database_id > 5 AND state_desc = 'ONLINE';
    OPEN conf_cursor; FETCH NEXT FROM conf_cursor INTO @db_name_conf;
    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @sql_conf = N'USE ' + QUOTENAME(@db_name_conf) + N';
                        INSERT INTO #DbConfigs ([Database], [Nivel_Compatibilidade], [Auto_Create_Stats], [Legacy_Cardinality_On], [Parameterization])
                        SELECT
                            DB_NAME(),
                            d.compatibility_level,
                            d.is_auto_create_stats_on,
                            ISNULL(CAST(lce.value AS BIT), 0),
                            CASE WHEN d.is_parameterization_forced = 1 THEN ''FORCED'' ELSE ''SIMPLE'' END
                        FROM
                            sys.databases AS d
                        LEFT JOIN
                            sys.database_scoped_configurations AS lce ON lce.name = ''LEGACY_CARDINALITY_ESTIMATION''
                        WHERE
                            d.database_id = DB_ID();';
        EXEC sp_executesql @sql_conf;
        FETCH NEXT FROM conf_cursor INTO @db_name_conf;
    END
    CLOSE conf_cursor; DEALLOCATE conf_cursor;

    SELECT '5_Config_Databases' AS Ponto_de_Verificacao, * FROM #DbConfigs ORDER BY [Database];
    IF @@ROWCOUNT = 0
    BEGIN
        SELECT '5_Config_Databases' AS Ponto_de_Verificacao, 'Nenhum BD encontrado (ID > 5)' AS [Database], NULL AS [Nivel_Compatibilidade], NULL AS [Auto_Create_Stats], NULL AS [Legacy_Cardinality_On], NULL AS [Parameterization];
    END
    DROP TABLE #DbConfigs;
    PRINT CHAR(10);

    -- =====================================================================
    -- 6. STATUS CRÍTICO DO LOG POR REPLICAÇÃO/CDC (Databases > 5)
    -- =====================================================================
    PRINT '--- 6. Status Crítico do Log por Replicação/CDC ---';
    PRINT 'INFO: Verifica se o log está BLOQUEADO para bancos com database_id > 5.';

    IF EXISTS (SELECT 1 FROM sys.databases WHERE log_reuse_wait_desc IN ('REPLICATION', 'CDC') AND database_id > 5)
    BEGIN
        SELECT '6_Status_Critico_Log_Repl_CDC' AS Ponto_de_Verificacao, name AS [Database], log_reuse_wait_desc AS [Status_Bloqueio_Log]
        FROM sys.databases WHERE log_reuse_wait_desc IN ('REPLICATION', 'CDC') AND database_id > 5;
    END
    ELSE
    BEGIN
        SELECT '6_Status_Critico_Log_Repl_CDC' AS Ponto_de_Verificacao, 'Nenhum problema encontrado' AS [Database], 'OK' AS [Status_Bloqueio_Log];
    END
    PRINT CHAR(10);

    -- =====================================================================
    -- 7. PAGE LIFE EXPECTANCY (PLE) (NÍVEL DE INSTÂNCIA)
    -- =====================================================================
    PRINT '--- 7. Page Life Expectancy (PLE) ---';
    SELECT '7_Page_Life_Expectancy_PLE' AS Ponto_de_Verificacao, cntr_value AS [PLE_Value_in_Seconds]
    FROM sys.dm_os_performance_counters WHERE object_name LIKE '%Buffer Manager%' AND counter_name = 'Page life expectancy';
    PRINT CHAR(10);

    -- =====================================================================
    -- 8. CADEIAS DE BLOQUEIO ATIVAS (Todos os BDs)
    -- =====================================================================
    PRINT '--- 8. Cadeias de Bloqueio Ativas ---';
    PRINT 'INFO: Lista sessões bloqueadas e bloqueadoras (se houver).';

    IF EXISTS ( SELECT 1 FROM sys.dm_os_waiting_tasks wt
                JOIN sys.dm_exec_sessions es_wait ON wt.session_id = es_wait.session_id
                WHERE wt.session_id > 50 AND es_wait.is_user_process = 1 AND wt.wait_type LIKE 'LCK_M_%')
    BEGIN
        SELECT
            '8_Bloqueios_Ativos' AS Ponto_de_Verificacao,
            wt.session_id AS [Waiter_Session_ID],
            DB_NAME(er_wait.database_id) AS [Waiter_Database],
            es_wait.login_name AS [Waiter_Login],
            es_wait.host_name AS [Waiter_Host],
            wt.wait_duration_ms AS [Waiter_Wait_ms],
            wt.wait_type AS [Waiter_Wait_Type],
            (SELECT SUBSTRING(st.text, (er_wait.statement_start_offset/2)+1,
               ((CASE er_wait.statement_end_offset WHEN -1 THEN DATALENGTH(st.text) ELSE er_wait.statement_end_offset END
                 - er_wait.statement_start_offset)/2) + 1)) AS [Waiter_SQL],
            wt.blocking_session_id AS [Blocker_Session_ID],
            es_block.login_name AS [Blocker_Login],
            es_block.host_name AS [Blocker_Host],
            (SELECT SUBSTRING(st_block.text, (er_block.statement_start_offset/2)+1,
               ((CASE er_block.statement_end_offset WHEN -1 THEN DATALENGTH(st_block.text) ELSE er_block.statement_end_offset END
                 - er_block.statement_start_offset)/2) + 1)) AS [Blocker_SQL]
        FROM
            sys.dm_os_waiting_tasks wt
        JOIN
            sys.dm_exec_sessions es_wait ON wt.session_id = es_wait.session_id
        JOIN
            sys.dm_exec_requests er_wait ON wt.session_id = er_wait.session_id
        LEFT JOIN
            sys.dm_exec_sessions es_block ON wt.blocking_session_id = es_block.session_id
        LEFT JOIN
            sys.dm_exec_requests er_block ON wt.blocking_session_id = er_block.session_id
        CROSS APPLY
            sys.dm_exec_sql_text(er_wait.sql_handle) AS st
        OUTER APPLY
            sys.dm_exec_sql_text(er_block.sql_handle) AS st_block
        WHERE
            wt.session_id > 50
            AND es_wait.is_user_process = 1
            AND wt.wait_type LIKE 'LCK_M_%';
    END
    ELSE
    BEGIN
        SELECT '8_Bloqueios_Ativos' AS Ponto_de_Verificacao, NULL AS [Waiter_Session_ID], 'Nenhum bloqueio encontrado' AS [Waiter_Database], NULL AS [Waiter_Login], NULL AS [Waiter_Host], NULL AS [Waiter_Wait_ms], NULL AS [Waiter_Wait_Type], NULL AS [Waiter_SQL], NULL AS [Blocker_Session_ID], NULL AS [Blocker_Login], NULL AS [Blocker_Host], NULL AS [Blocker_SQL];
    END
    PRINT CHAR(10);

    -- =====================================================================
    -- 9. SPIDS ANTIGOS (EM EXECUÇÃO HÁ MAIS DE 1 DIA) (Databases > 5)
    -- =====================================================================
    PRINT '--- 9. SPIDs em execução há mais de 1 dia ---';
    PRINT 'INFO: Lista sessões antigas cujo contexto atual é um banco com database_id > 5.';
    SELECT '9_SPIDs_Antigos_Mais_de_1_Dia' AS Ponto_de_Verificacao, s.session_id, s.login_name, s.host_name, s.program_name,
        s.login_time, DATEDIFF(hour, s.login_time, GETDATE()) AS 'HorasAtivo', s.status, st.text AS 'LastSQLText'
    FROM sys.dm_exec_sessions AS s LEFT JOIN sys.dm_exec_connections AS c ON s.session_id = c.session_id
    OUTER APPLY sys.dm_exec_sql_text(c.most_recent_sql_handle) AS st
    WHERE
        s.is_user_process = 1
        AND s.login_time < DATEADD(day, -1, GETDATE())
        AND s.database_id > 5
        AND s.login_name <> 'sa'
        AND s.login_name NOT LIKE '%GodFather%'
        AND s.login_name NOT LIKE '%prtsql%' -- AJUSTE: Adicionado filtro
    ORDER BY
        s.login_time ASC;
    IF @@ROWCOUNT = 0
    BEGIN
        SELECT '9_SPIDs_Antigos_Mais_de_1_Dia' AS Ponto_de_Verificacao, NULL AS session_id, 'Nenhuma sessão > 1 dia encontrada' AS login_name, NULL AS host_name, NULL AS program_name, NULL AS login_time, NULL AS HorasAtivo, NULL AS status, NULL AS LastSQLText;
    END
    PRINT CHAR(10);

    -- =====================================================================
    -- 10. LATÊNCIA DE DISCO (IO) (Databases > 5)
    -- =====================================================================
    PRINT '--- 10. Latência de Disco (Média em ms) ---';
    PRINT 'INFO: Mede a latência de I/O para arquivos de bancos com database_id > 5.';
    SELECT '10_Latencia_Disco_IO' AS Ponto_de_Verificacao, DB_NAME(fs.database_id) AS [Database], mf.physical_name AS [Arquivo],
        fs.io_stall_read_ms AS [Total Read Stall (ms)], fs.num_of_reads AS [Total Reads],
        CAST(fs.io_stall_read_ms / NULLIF(fs.num_of_reads, 0) AS DECIMAL(10, 2)) AS [Latência Média Leitura (ms)],
        fs.io_stall_write_ms AS [Total Write Stall (ms)], fs.num_of_writes AS [Total Writes],
        CAST(fs.io_stall_write_ms / NULLIF(fs.num_of_writes, 0) AS DECIMAL(10, 2)) AS [Latência Média Escrita (ms)]
    FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS fs
    INNER JOIN sys.master_files AS mf ON fs.database_id = mf.database_id AND fs.file_id = mf.file_id
    WHERE
        (fs.num_of_reads > 0 OR fs.num_of_writes > 0)
        AND fs.database_id > 5
    ORDER BY
        [Latência Média Leitura (ms)] DESC, [Latência Média Escrita (ms)] DESC;
    IF @@ROWCOUNT = 0
    BEGIN
        SELECT '10_Latencia_Disco_IO' AS Ponto_de_Verificacao, 'Nenhuma atividade de I/O registrada para BDs (ID > 5)' AS [Database], NULL AS [Arquivo], NULL AS [Total Read Stall (ms)], NULL AS [Total Reads], NULL AS [Latência Média Leitura (ms)], NULL AS [Total Write Stall (ms)], NULL AS [Total Writes], NULL AS [Latência Média Escrita (ms)];
    END
    PRINT CHAR(10);

    PRINT '=====================================================================';
    PRINT '==                   FIM DO HEALTH CHECK                           ==';
    PRINT '=====================================================================';

END;
GO
